---
layout: blog
title: C函数解析
---

<h1 id="toc_0">内核学习记录</h1>

<h2 id="toc_1">用户空间和内核控件</h2>

<div><pre><code class="language-none">为了保证用户进程不能直接操作内核，保证内核的安全，操作系统将虚
拟控件划分为内核空间和用户空间。 每个进程可以通过系统调用进入
内核，Linux内核由系统内所有进程共享。
有了用户空间和内核空间，整个linux内部结构分为: 硬件 --&gt; 内
核空间 --&gt; 用户空间
   - 内核空间存放内核代码和数据，而进程的用户空间存放用户程序
     的代码和数据。不管是内核还是用户空间，都处于虚拟空间。
   - Linux使用两级保护机制: 0级供内核使用， 3级供用户程序使
     用</code></pre></div>

<p><img src="../../../_images/kernel.png" alt="Alt text"></p>

<h2 id="toc_2">用户态和内核态</h2>

<div><pre><code class="language-none">1. 当进程执行系统调用而陷入内核代码中执行时，则处于内核态。此
   时使用进程的内核栈。
2. 当进程执行用户自己的代码时，则处于用户运行态。</code></pre></div>

<h3 id="toc_3">进程上下文</h3>

<div><pre><code class="language-none">程序在执行过程中通常有用户态和内核态两种状态，CPU根据上下文环
境分为3种状态:
- 用户级上下文: 正文，数据，用户堆栈以及共享存储区
- 寄存器上下文: 通用寄存器,程序寄存器(IP),处理器状态寄存器
  (EFLAGS),栈指针(ESP)
- 系统级上下文: 进程控制块task_struct,内存管理信息(mm_struct, vm_area_struct, pgd, pte), 内核栈</code></pre></div>

<h3 id="toc_4">上下文切换</h3>

<div><pre><code class="language-none">当发生进程调度时，进行进程切换就是上下文切换(context switch)。 
操作系统必须对上面提到的全部信息进行切换，新调度的进程才能运
行。而系统调用进行的模拟切换(mode switch)。 模式切换和进程
切换比较起来，容易的多，而且节省时间，因为模式切换最主要的任务
只是切换进程寄存器上下文的切换。</code></pre></div>

