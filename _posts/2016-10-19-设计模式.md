---
layout: blog
title: vim命令速查卡
---

# 设计模式总结
## 创建型
### Abstract Factory
    将工厂做抽象，根据输入选择工厂，再由工厂生产对应对象
### Build
    将对象的创建和他的表现分离，根据预置的对象来实现对输入的不同：处理方式
### Factory
    对产品做抽象，根据输入选择生产的对象
### Object Pool  
    维护一个对象池，在需要的时候产生对象放入池中，使用时取出，使用完再放回对象池
### Prototype
    预先在维护不同对象的列表，再根据输入，选择不同的对象进行clone
### Singleton
    全局维护一个对象
    
## 结构设计型
### Adapter
    将旧有接口做包装，以提供新接口给调用者
### Bridge
    将接口和实现分离，即提供一个抽象接口，由其他类实现
### Composite
    将各种实现组合到另一个类中
### Decorator
    由一个相同的对象包装另一个对象，并新加入
### Facade
    一个类中包装一个流程的实现，对用户提供一个简单的接口
### FlyWeight
    内部存储都种类型的实例，根据输入获取对应的实例，实现共享
### Private Class Data
    将数据成员和对象分离，控制对数据的修改
### Proxy
    代理，包装被代理类，实现被代理类的所有方法，控制外部对被代理类的访问
##行为型
### Chain of Responsibility
    将操作的每一部封装成一个对象，然后串成一个链表
### Command
    将操作的步骤封装成一个cmd对象
### Interpreter
    封装对一个输入的解释
### Iterator
    封装遍历序列的细节
### Mediator
    封装几个类之间的交互方式
### Memento
    在不破坏对象封装的情况下，获取执行的状态
### Null Object
    空对象，不做任何操作，避免和null判断
### Observer
    向另一个对象注册自己，当该对象的某个状态变化时，通知自己
### Stat
    将过程中的状态变成一个对象
### Strategy
    封装一个算法或策略，屏蔽细节
### Template method
    定义一种类型的类的行为模板
### Visitor 
    数据结构和数据操作分离

具体可参见
[design_patterns](https://sourcemaking.com/design_patterns)
